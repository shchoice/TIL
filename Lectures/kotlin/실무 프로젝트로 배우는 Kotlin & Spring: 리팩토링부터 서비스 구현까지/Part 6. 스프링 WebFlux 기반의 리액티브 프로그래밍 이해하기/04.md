# **리액티브 프로그래밍**

# **1. 리액티브 프로그래밍이란**

- 리액티브 프로그래밍은 데이터 또는 이벤트의 변경이 발생하면 이에 반응해 처리하는 프로그래밍 기법을 말함
- 비동기 프로그래밍을 처리하는 새로운 접근 방식
- 데이터의 통지, 완료, 에러에 대한 처리를 옵저버 패턴에 영감을 받아 설계되었고 데이터의 손쉬운 비동기 처리를 위해 함수형 언어의 접근 방식을 사용
- 2010년 에릭 마이어에 의해 마이크로소프트 .NET 에코 시스템으로 정의됨

리액티브 프로그래밍 이전의 비동기 프로그래밍

- 리액티브 프로그래밍이 나오기 전 비동기 프로그래밍은 대부분 `콜백`기반의 비동기 처리 방식을 사용

  - 간단한 콜백은 이해하기 쉬울 수 있지만 콜백이 많아져서 발생하는 콜백 헬로 인해 코드의 복잡도가 늘어남

  ```
  etch("/api/users/me") { user->
        fetch("/api/users/${user.id}/followers") { followers ->
            fetch("/api/users/${user.id}/likes") { likes ->
                fetch("/api/users/${user.id}/contacts") { contacts ->
                }
            }
        }
  }
  ```

리액티브 프로그래밍을 적용한 사례

- 리액티브 프로그래밍을 사용하면 콜백 헬 문제를 함수형 프로그래밍 관점으로 해결할 수 있음

  - 콜백 헬 없이 비동기 코드를 쉽게 작성할 수 있기 때문에 서버나 UI 애플리케이션 개발 시 리액티브 프로그래밍이 유용하게 사용됨

  ```
  fetchReactive("/api/users/me")
      .zip { user -> fetchReactive("/api/users/${user.id}/followers") }
      .zip { user -> fetchReactive("/api/users/${user.id}/likes") }
      .zip { user -> fetchReactive("/api/users/${user.id}/contacts") }
      .flatMap { followers, likes, contacts ->
                  // Fh직구현
   }
  ```

# **리액티브 스트림**

- 리액티브 스트림은 리액티브 프로그램의 표준 API 사양을 말함
- 비동기 데이터 스트림과 Non-blocking Back-Pressure에 대한 사양을 제공
- 리액티브 스트림 이전의 비동기식 애플리케이션에서는 CPU의 멀티 코어를 제대로 활용하기 위해 복잡한 병렬 처리 코드가 필요했음
- 기존의 방식은 처리할 데이터가 무한정 많아져서 시프템의 한계를 넘어서는 경우 애플리케이션은 병목현상이 발생하거나 심각한 경우 애플리케이션이 정지되는 경우도 있음
- Netflix, Vmware, Redhat, Twitter, Lightbend 등과 같은 유명 회사들이 표준화에 참여 중

리액티브 스트림의 다양한 구현체들

- 리액티브 스트림은`TCK(Technology Compatibility Kit)` 를 지원하기 때문에 라이브러리가 정해진 사양에 맞게 구현되었는지 보장

  > TCK는 라이브러리가 정해진 사양에 맞게 구현되었는지 보장하기 위해 만들어진 테스트 도구 자바 진영에선 Java SE 표준을 따른 JDK인지 검증하기 위해 TCK를 사용

- 리액티브 스트림은 TCK만 통과한다면 각 구현체들은 표준 사양에 포함되지 않은 라이브러리만의 추가 기능도 자유롭게 지원할 수 있게 함

리액티브 스트림을 표준 사양을 채택한 대표적인 구현체들

- Project Reactor
- RxJava
- JDK9 Flow
- Akka Streams
- Vert.x

리액티브 스트림 사양

- 리액티브 스트림 사양(specification)은 `핵심 인터페이스`와 `프로토콜`로 구성됨

  ![https://user-images.githubusercontent.com/100276387/235466449-2dfc818e-b76b-4f58-aa34-3482ffb25f6f.png](https://user-images.githubusercontent.com/100276387/235466449-2dfc818e-b76b-4f58-aa34-3482ffb25f6f.png)

  | Interface          | Description                                                  |
  | ------------------ | ------------------------------------------------------------ |
  | Publisher(발행자)  | 데이터를 생성하고 Subscriber에게 통지                        |
  | Subscriber(구독자) | 데이터를 구독하고 통지 받은 데이터를 처리                    |
  | Subscription       | Publisher, Subscriber 간의 데이터를 교환하도록 연결하는 역할을 하며 전달받을 데이터의 개수를 설정하거나 구독을 해지할 수 있음 |
  | Processor          | Publiser, Subscriber을 모두 상속 받은 인터페이스             |

  - Publisher(발행자)는 데이터를 생성하고 Subscriber(구독자)에게 데이터를 통지하고 Subscriber는 자신이 처리할 수 있는 만큼의 데이터를 요청하고 처리
    - Publisher가 제공할 수 있는 데이터의 양은 `무한(unbounded)`하고 `순차적(sequential)` 처리를 보장
  - Subscription은 Publisher와 Subscriber를 연결하는 매개체이며 Subscriber가 데이터를 요청하거나 구독을 해지하는 등 데이터 조절에 관련되 역할을 담당
  - Processor 는 Publishe와 Subscriber의 기능을 모두 포함하는 interface이며 데이터를 가공하는 중간 단계에서 사용



리액티브 스트림의 데이터 처리 프로토콜

- 리액티브 스트림은 Publisher, Subscriber 간의 데이터 전달에 사용되는 규칙을 `Protocol(규약)`로 정의

- Subscriber는 4개의 추상 메서드를 protocol로 가지고 있음

  ```java
  public interface Subscriber<T> {
  	public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
  }
  ```

  | Method      | Description                                                  |
  | ----------- | ------------------------------------------------------------ |
  | onSubscribe | 구독시 최초에 한번만 호출                                    |
  | onNext      | 구독자가 요구하는 데이터의 수 만큼 호출(최대 java.lang.Long.MAX_VALUE) |
  | onError     | 에러 또는 더이상 처리할 수 없는 경우                         |
  | onComplete  | 모든 처리가 정상적으로 완료된 경우                           |